

# چطور کدی را تعریف کنم که به وسیله اینستنس و یا کلاس متد ها و نه استاتیستیک متد اینو حل کنم؟
# از این کد خوشم نمیاد چون عملا اینستنس ننوشتم 
# اینجا اومدم از کتابخونه استاتیسستیک مین را اوردم  تا بعدا میانگین را استفاده کنم
# تازه اصلا ارث بری و کارهاشو هم انجام ندادم
# ضمن اینکه خیلی طولانی شده


from statistics import mean
class A:
    # کلاسی تعریف کردم با اینیت هر چند توی کد من هیچ کاربردی از سلف و.. نداره
    def __init__(self,ghad,vazn,sen):
        self.ghad=ghad
        self.vazn=vazn
        self.sen=sen
    # از طریق  تابع استاتیستیک اوردم 
    # انگار تابع محور کد نوشتم ولی  رد کلاس 
    # منتها خوبی کلاس این بود که یه بار ازش به ارث بردم
    # که اونم به گمونم عملا میتونستم یه جوز دیگه هم بنویسم
    @staticmethod
    def miangin():
        # اینجا تابعی را تعریف کردم
        # در اینجا یه عدد الکی بگیرم چون ورودی را میخواد
        mynumber=int(input(''))
        # بعد در اینجا اومدم ورودی گرفتم که هر استرینگ را جدا کنه بریزه توی یه لیست بعد میانگین کنه
        # برای قد و وزن هم همچنین
        sen=mean([float(i) for i in input('').split()])
        ghad=mean([float(i) for  i in input('').split()])
        vazn=mean([float(i) for i in input('').split()])
        # ریترنشون کردم  فقط حواست باشه که در ریترن به همون ترتیب ورودی یعنی سن و قد و وزن بنویسی نه جاجا چون جلوتر مشکل میخوری اگر نکنی
        return (sen,ghad,vazn)  
# کلاس بی از ای ارث میبره عینا همونه فقط اسمش فرق داره
class B(A):
    pass


# متغیر را مساوی کلاس قرار دادم بدون پرانتز هم میشه چون اگر پرانتز میزاشتم باید سلف و سایر مشخضات را میدادم
my_A=A
# بعد اون تابع درون کلاس را فراخوانی میکنم 
# سن و قد و وزن را بهم بده برای کلاس الف
# میریزم تو یه متغیر دیگر 
my_aa=(my_A.miangin())
# بعد برای اینکه بهم نریزه  توی دیکشنری میریم که طبق انومریت خروجی بده در حلقه بهم
# هرچند به گمونم تاپل ها اینپلیس باشند  و ترتیب ورودی را حفظ کنن
my_Aa=dict(enumerate(my_aa))
# print(my_Aa)
# ازمایشی پرینت میکنم

# همین مراحل را برای کلاس بی انجام میدم
my_B=B
myBb=(my_B.miangin())
mybb=dict(enumerate(myBb))
# print(mybb)

# بعد تابعی میسازم که مقایسه کنه که اگر قد کل افراد کلاس ای از  بی  بیشتر بود پرنیت کنه کلاس الف 
def comparable():
   
    # برای مقایسه هم چون خروجی کلاس به ما تاپل میداد پس عنصر دومش میشه همون میانگین قد ها
    # که با عنصر دوم  کلاس بی مقایسه میشه 
    if my_Aa[1]> mybb[1]:
        print('A') 
    else:
        if my_Aa[1]==mybb[1]:
            if my_Aa[2]<mybb[2]:
                print('A')
            else:
                if my_Aa[2]>mybb[2]:
                   print('B') 
                else:
                    print('Same')
                print('B')
        else:
            print('B')

# بعد میایم پرینت میکنیم که طبق خروجی باشه
# چون انومریت دیکشنری کردم باید  ولیو ها را پرینت کنه
# برای همین میایم از شیوه دیکشنری استفاده میکنم       که حلقه میزنه  
for charA in my_Aa:
    print(my_Aa[charA])
for charB  in mybb:
    print(mybb[charB])

# give me the number of whole:5
# give me the sen: 16 1
# 7 15 16 17
# give me the ghad numbers: 180 175 172 170
# 165
# give me the vazn: 67
# 72 59 62 55
# {0: 172.4, 1: 63.0, 2: 16.2}
# give me the number of whole:5
# give me the sen: 15 1
# 7 16 15 16
# give me the ghad numbers: 16 156 168 170 1
# 62
# give me the vazn: 45
# 52 56 58 47
# {0: 134.4, 1: 51.6, 2: 15.8}
# 172.4
# 63.0
# 16.2
# 134.4
# 51.6
# 15.8


# در اخر هم اون تابع مقایسه را فراخوانی میکنم تا بهم بگهطبق شرایط خواسته الف را بده یا ب را؟
comparable()
# A


